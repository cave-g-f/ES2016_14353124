## 死锁

###一、死锁的必要条件

**互斥条件：**一个资源每次只能被一个进程使用。
**请求与保持条件：**一个进程因请求资源而阻塞时，对已获得的资源保持不放。
**不剥夺条件:**进程已获得的资源，在末使用完之前，不能强行剥夺。
**循环等待条件:**若干进程之间形成一种头尾相接的循环等待资源关系

###二、实验截图
![这里写图片描述](http://img.blog.csdn.net/20161022170019213)
可以看出在运行到第188次时发生死锁。

###三、原因解释

可以看出按照正常情况，程序每被创建一次，就会先执行run函数，然后经过一个count的时间执行methodA函数。那么当一个进程执行完run函数后，就会开始进入循环，下一个进程开始执行run函数如果在执行过程中前面的进程恰好开始执行methodA函数，由于同一时间不能访问同一对象的所有方法，因此前面的进程就会运行这个方法的进程释放资源。当释放资源后，前一进程获得资源，但是这个时候进程又开始执行methodB函数，导致前一进程又被堵塞，这时就会发生死锁。






